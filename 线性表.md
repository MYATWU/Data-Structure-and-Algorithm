线性表定义：具有**相同特性**的数据元素的一个**有限的线性的***序列。
若n为表长，n = 0时为空表。
***
**[顺序表](#p1)**

## 1. 顺序表
### 1.1理论
- 定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的顺序存储结构。
线性表的顺序表示又称为顺序存储结构或顺序映像，简称顺序表。
第1个数据元素存储位置成为线性表的起始地址或基地址。

- 物理存储要求：依次存储，地址连续，**中间没有空出存储单元**，占用一片连续的存储空间。
- 顺序表特点：
	1. 以物理位置相邻表示逻辑关系
	2. 任一元素可随机存取（优点）

**顺序表与数组**
- 共同点：地址连续、依次存放、随寄存取、类型相同
- 差别：线性表长度可变（删除），数组长度不可动态定义

**多项式的顺序存储结构定义**

$$
P_n(x) = p_1x^{e_1} + p_2x^{e_2} + ... + p_mx^{e_m}.
$$

线性表 $P((p_1, e_1), (p_2, e_2), ... , (p_m, e_m))$
### 1.2 实现
#### 1.2.1 预定义
~~~cpp
#define   TRUE 1
#define   FALSE 0
#define   OK 1
#define   ERROR 0
#define   INFEASIBLE -1
#define   SQ_OVERFLOW -2
~~~
#### 1.2.2 顺序表类定义
~~~cpp
class SqList {
public:
	//Status  是函数的类型，其值是函数结果状态代码
	typedef   int   Status;
	typedef   char   ElemType;
	SqList();
	~SqList() = default;
	void Destroy();
	void Clear();
	size_t GetLength() const;
	size_t GetSize() const;
	Status IsEmpty() const;
	Status GetElem(size_t i, ElemType& e) const;
	size_t LocateElem(const ElemType& e) const;
	Status Insert_Sq(size_t i, const ElemType& e);
	Status Delete(size_t i, ElemType& e);
private:
	void reallocate();
	shared_ptr<ElemType> elem;
	size_t length;
	size_t size;
};
~~~
#### 1.2.2 顺序表构造函数
~~~cpp
SqList::SqList() : elem(new ElemType[1]), length(0), size(1) {
	if (!elem)
		exit(SQ_OVERFLOW);
}
~~~
#### 1.2.3 顺序表销毁
~~~cpp
void SqList::Destroy()
{
	this->~SqList();
}
~~~
#### 1.2.4 清空顺序表
~~~cpp
void SqList::Clear()
{
	length = 0;
}
~~~
#### 1.2.5 获取顺序表长度
~~~cpp
size_t SqList::GetLength() const
{
	return length;
}
~~~
#### 1.2.6 获取顺序表空间大小
~~~cpp
size_t SqList::GetSize() const
{
	return size;
}
~~~
#### 1.2.7 判断顺序表是否为空
~~~cpp
SqList::Status SqList::IsEmpty() const
{
	if (length != 0)
		return FALSE;
	else
		return TRUE;
}
~~~
#### 1.2.8 获取第i个元素
~~~cpp
SqList::Status SqList::GetElem(size_t i, ElemType& e) const
{
	if (i < 1 || i > length)
		return ERROR;
	e = elem.get()[i - 1];
	return OK;
}
~~~
#### 1.2.9 定位元素
~~~cpp
size_t SqList::LocateElem(const ElemType& e) const
{
	for (size_t i = 0; i < length; ++i)
		if (elem.get()[i] == e)
			return i + 1;
	return 0;
}
~~~
#### 1.2.10 重新分配空间
~~~cpp
void SqList::reallocate()
{
	auto newspace = size ? size * 2 : 1;
	shared_ptr<ElemType> temp(new ElemType[newspace]);
	for (size_t i = 0; i < length; ++i)
		temp.get()[i] = std::move(elem.get()[i]);
	elem = temp;
	size = newspace;
}
~~~
#### 1.2.11 插入元素
~~~cpp
SqList::Status SqList::Insert_Sq(size_t i, const ElemType& e)
{
	if (i < 1 || i > length + 1)
		return ERROR;
	if (length == size)
		reallocate();
	for (size_t j = length; j >= i; --j)
		elem.get()[j] = elem.get()[j - 1];
	elem.get()[i - 1] = e;
	length++;	
	return OK;
}
~~~
#### 1.2.12 删除元素
~~~cpp
SqList::Status SqList::Delete(size_t i, ElemType& e)
{
	if (i < 1 || i > length)
		return ERROR;
	e = elem.get()[i - 1];
	for (size_t j = i - 1; j < length; ++j)
		elem.get()[j] = elem.get()[j + 1];
	length--;
	return OK;
}
~~~
