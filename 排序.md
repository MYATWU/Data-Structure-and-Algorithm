## 1 排序方法分类
- 按存储介质：

&ensp;内部排序：数据量不大、数据在内存，无需内外存交换数据

&ensp;外部排序：数据量较大、数据在外存（文件排序），排序时要将数据分批调入内存来排序，中间结果还要及时放入外存

- 按比较器个数：

&ensp;串行排序：单处理机（同一时刻比较一对元素）

&ensp;并行排序：多处理机（同一时刻比较多对元素）

- 按主要操作：

&ensp;比较排序：插入排序、交换排序、选择排序、归并排序

&ensp;基数排序：不比较元素的大小，仅仅根据元素本身的取值确定其有序位置

- 按辅助空间：

&ensp;原地排序：辅助空间用量为O(1)

&ensp;非原地排序：辅助空间用量超过O(1)

- 按稳定性：

&ensp;稳定排序：能够使任何数值相等的元素排序以后相对次序不变

&ensp;非稳定排序：不是稳定排序的方法

&ensp;排序稳定性只对结构类型数据有意义

- 按自然性：

&ensp;自然排序：输入数据越有序，排序速度越快的排序方法

&ensp;非自然排序：不是自然排序的方法
## 2 存储结构
~~~cpp
#define MAXSIZE 20 //设记录不超过20个
typedef int KeyType;  //设关键字为整型量（int型）
Typedef struct {          //定义每个记录（数据元素）的结构
	KeyType key;           //关键字
	InfoType otherinfo; //其他数据项
} RedType;                    //Record Type
Typedef struct {                     //定义顺序表的结构
	RedType r[MAXSIZE + 1];//存储顺序表的向量
	                                            //r[0]一般作哨兵或缓冲区
	int length;                           //顺序表的长度
} SqList;
~~~
## 3 插入排序
### 3.1 直接插入排序
- 采用顺序查找法
#### 3.1.1 实现
~~~cpp
void InsertSort(SqList& L)
{
	for (int i = 2; i <= L.length; ++i)
	{
		if (L.r[i].key < L.r[i - 1].key)
		{
			//若“<”，需将L.r[i]插入有序子表
			L.r[0] = L.r[i];//复制为哨兵
			for (int j = i - 1; L.r[j].key > L.r[0].key; --j)
				L.r[j + 1] = L.r[j];//记录后移
			L.r[j + 1] = L.r[0];//插入到正确位置
		}
	}
}
~~~
#### 3.1.2 效率分析
- 实现排序的基本操作有两个：

&ensp;1）“比较”序列中两个关键字的大小；

&ensp;2）“移动”记录

- 最好的情况（关键字在记录序列中顺序有序）：

&ensp;比较次数：

$$
\sum_{i = 2}^{n}1 = n - 1
$$

&ensp;移动次数：0

- 最坏的情况（关键字在记录序列中逆序有序）：

&ensp;比较次数：

$$
\sum_{i=2}^{n}i=\frac{(n+2)(n-1)}{2}
$$

&ensp;移动次数：

$$
\sum_{i=2}^{n}(i+1)=\frac{(n+4)(n-1)}{2}
$$

- 原始数据越接近有序，排序速度越快
- 最坏情况下 $T_w(n) = O(n^2)$
- 平均情况下，耗时差不多是最坏情况的一半 $T_e(n) = O(n^2)$
- 空间复杂度O(1)
### 3.2 折半插入排序
#### 3.2.1 实现
~~~cpp
void BInsertSort(SqList& L)
{
	for (int i = 2; i <= L.length; ++i)
	{
		L.r[0] = L.r[i];
		low = 1;
		high = i - 1;
		while (low <= high)
		{
			mid = (low + high) / 2;
			if (L.r[mid].key < L.r[0].key)
				low = mid + 1;
			else 
				high = mid - 1;
		}
		for (int j = i - 1; j >= high + 1; --j)
			L.r[j + 1] = L.r[j];
		L.r[high + 1] = L.r[0];
	}
}
~~~
#### 3.2.2 算法分析
- 折半查找比顺序查找快，所以折半插入排序就平均性能来说比直接插入排序要好
- 关键码比较次数与待排序对象序列初始排列无关，仅依赖于对象个数。在插入第i个对象时，最坏情况下要经过 $\llcorner log_2i \lrcorner + 1$ 次关键码比较，才能确定它应插入的位置
- 当n较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差
- 在对象的初始排列已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行的关键码比较次数要少
- 移动次数与直接插入排序相同，依赖于对象的初始排列
- 减少了比较次数
- 时间复杂度为O( $n^2$ )
- 空间复杂度为O(1)
- 是一种稳定的排序方法
### 3.3 希尔排序
1. 定义增量序列 $D_k$ : $D_M > D_{M-1} > ... > D_1 = 1$
2. 对每个 $D_K$ 进行“ $D_K$ 间隔”插入排序
#### 3.3.1 实现
~~~cpp
void ShellSort(SqList& L, int dlta[], int t)
{
	//按增量序列dlta[0...t-1]对顺序表L作希尔排序
	for (int k = 0; k < t; ++k)
		ShellInsert(L, dlta[k]); //一趟增量为dlta[k]的插入排序
}
~~~
~~~cpp
void ShellInsert(SqList& L, int dk)
{
	for (int i = dk + 1; i <= L.length; ++i)
	{
		if (L.r[i].key < L.r[i - dk].key)
		{
			L.r[0] = L.r[i];
			for (int j = i - dk; j > 0 && (L.r[0].key < L.r[j].key; j -= dk)
				L.r[j + dk] = L.r[j];
			L.r[j + dk] = L.r[0];
		}
	}
}
~~~
#### 3.3.2 算法分析
- 时间复杂度是n和d的函数：O( $n^1.25$ ) ~ O( $1.6n^1.25$ )——经验公式
- 空间复杂度O(1)
- 是一种不稳定的排序方法
- 如何选择最佳d序列目前尚未解决
- 最后一个增量值必须为1，无除了1之外的公因子
- 不宜在链式存储结构上实现
## 4 交换排序
### 4.1 冒泡排序
- 基本思想：每趟不断将记录两两比较，并按“前小后大”规则交换
#### 4.1.1 实现
~~~cpp
void bubble_sort(SqList& L)
{
	RedType x;
	for (int i = 1; i <= L.length - 1; ++i)//总共需要i趟
	{
		for (int j = 1; j <= L.length - i; ++j)//每趟需要比较j次，i和j的和为length
		{
			if (L.r[j].key > L.r[j + 1].key)
			{
				x = L.r[j];
				L.r[j] = L.r[j + 1];
				L.r[j + 1] = x;
			}
		}
	}
}
~~~
- 优点：每趟结束时，不仅能挤出一个最大值到最后面位置，还能同时部分理顺其他元素
- 一旦某一趟比较时不出现记录交换，说明已排好序了，就可以结束本算法
- 改进后
~~~cpp
void bubble_sort(SqList& L)
{
	int flag = 1;
	RedType x;
	for (int i = n -1; flag == 1 && i >= 1; --i)
	{
		flag = 0;
		for (int j = 1; j <= i; ++j)
		{
			if (L.r[j].key > L.r[j + 1].key)
			{
				flag = 1;
				x = L.r[j];
				L.r[j] = L.r[j + 1];
				L.r[j + 1] = x;
			}
		}
	}
}
~~~
#### 4.1.2 算法分析
- 最好情况（正序）

&ensp;比较次数：n - 1

&ensp;移动次数： 0

&ensp;时间复杂度：O(n)

- 最坏情况（逆序）

&ensp;比较次数：

$$
\sum_{i = 1}^{n-1}(n-i)=\frac{1}{2}(n^2 - n)
$$

&ensp;移动次数：

$$
3\sum_{i = 1}^{n-1}(n-i)=\frac{3}{2}(n^2 - n)
$$

&ensp;时间复杂度：O( $n^2$ )

- 平均时间复杂度：O( $n^2$ )
- 空间复杂度：O(1)
- 冒泡排序是稳定的
### 4.2 快速排序
- 基本思想：任取一个元素（如第一个）为中心（pivot：枢轴，中心点），所有比它小的元素一律前放，比它大的元素一律后放，形成左右两个子表，对各子表重新选择中心元素并以此规则调整，直到每个子表的元素只剩一个
#### 4.2.1 实现
~~~cpp
void main()
{
	QSort(L, 1, L.length);
}
~~~
~~~cpp
void QSort(SqList& L, int low, int high)
{
	if (low <high)//长度大于1
	{
		//将L.r[low...high]一分为二，pivotloc为枢轴元素排好序的位置
		pivotloc = Partition(L, low, high);
		QSort(L, low, pivotloc - 1);//对低子表递归排序
		QSort(L, pivotloc + 1, high);//对高子表递归排序
	}
}
~~~
~~~cpp
int Partition(SqList& L, int low, int high)
{
	L.r[0] = L.r[low];
	pivotkey = L.r[low].key;
	while (low < high)
	{
		while (low < high && L.r[high].key > pivotkey)
			--high;
		L.r[low] = L.r[high];
		while (high > low && L.r[low].key < pivotkey)
			++low;
		L.r[high] = L.r[low];
	}
	L.r[low] = L.r[0];
	return low;
}
~~~
#### 4.2.2 算法分析
- 平均计算时间：O( $nlog_2n$ )
- QSort：O( $log_2n$ )
- Partition：O(n)
- 实验结果表明：就平均计算时间而言，快速排序是我们所讨论的所有内排序方法中最好的一个
- 快速排序不是原地排序
- 由于程序中使用了递归，需要递归调用系统栈的支持，而栈的长度取决于递归调用的深度（即使不用递归，也需要用用户栈）
- 平均情况下：需要O( $logn$ )的栈空间
- 最坏情况下：栈空间可达O(n)
- 是一种不稳定的排序方法
- 快速排序不适于对原本有序或基本有序的记录序列进行排序（严格正序或逆序退化成没有改进措施的冒泡排序）
- 输入数据次序越乱，所选划分元素值的随机性越好，排序速度越快，快速排序不是自然排序方法
- 最坏情况下，快速排序时间复杂度为O( $n^2$ )
## 5 选择排序
### 5.1简单选择排序
- 基本思想：在待排序的数据中选出最大（小）的元素放在其最终的位置
#### 5.1.1 实现
~~~cpp
void SelectSort(SqList& L)
{
	for (int i = 1; i <= L.length; ++i)
	{
		int k = i;
		for (int j = i + 1; j < L.length; ++j)
		{
			if (L.r[j].key < L.r[k].key)//记录最小位置
				k = j;
		}
		if (k!=i)
		{
			RedType x;
			x = L.r[i];
			L.r[i] = L.r[k];
			L.r[k] = x;
		}
	}
}
~~~
#### 5.1.2 算法分析
- 移动次数：

&ensp;最好：0

&ensp;最坏： $3(n - 1)$

- 比较次数：无论待排序列处于什么状态，选择排序所需进行的比较次数相同

$$
\sum_{i=1}^{n-1}(n-i)=\frac{n}{2}(n-1)
$$

- 时间复杂度：O( $n^2$ )
- 不是稳定排序
- 空间复杂度：O(1)
### 5.2 堆排序
#### 5.2.1 理论
- 堆的定义：若n个元素的序列 ${a_1, a_2, ..., a_n}$ 满足 $a_i <= a_{2i}$ 和 $a_i <= a_{2i+1}$ ，则称该序列为小根堆，若满足 $a_i >= a_{2i}$ 和 $a_i >= a_{2i+1}$ ，则称该序列为大根堆
- 从堆的定义可以看出，堆实质是满足如下性质的完全二叉树：二叉树中任一非叶子节点均小于（大于）它的孩子结点
- 基本思想：输出堆顶的最小值（最大值）后使剩余n - 1个元素的序列重又建成一个堆，则得到n个元素的次小值（次大值），如此反复，得到有序序列，过程称为堆排序
- 堆的调整（小根堆）：
1. 输出根并以最后一个元素代替之
2. 比较其左右孩子值的大小，并与其中较小者交换
#### 5.2.2 实现
~~~cpp
void HeapAdjust(elem R[], int s, int m)
{
	//已知R[s...m]中记录的关键字除R[s]之外均满足堆的定义，本函数调整R[s]的关键字，使R[s...m]称为一个大根堆
	rc = R[s];
	for (int j = 2 * s; j <= m; j *= 2)//沿key较大的孩子结点向下筛选
	{
		if (j < m && R[j] < R[j + 1])
			++j;//j为key较大的记录的下标
		if (rc >= R[j])
			break;
		R[s] = R[j];
		s = j;
	}
	R[s] = rc;
}
~~~
