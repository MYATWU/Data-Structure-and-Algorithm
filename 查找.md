## 1 查找的基本概念
- 查找表：由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种灵便的结构
- 查找：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或（记录）
- 关键字：用来标识一个数据元素（或记录）的某个数据项的值
- 主关键字：可唯一标识一个记录的关键字
- 次关键字：用以标识若干记录的关键字
- 静态查找表：仅作“查询”（检索）操作的查找表
- 动态查找表：作“插入”和“删除”操作的查找表
- 平均查找长度： $\sum_{i = 1}^{n}p_ic_i$ ，n为记录的个数， $p_i$ 为查找第i个记录的概率（通常认为 $p_i = 1/n$ ）， $c_i$ 为找到第i个记录所需的比较次数
## 2 线性表的查找
### 2.1 顺序查找
- 应用范围：
1. 顺序表或线性链表的静态查找表
2. 表内元素之间无序
#### 2.1.1 实现
数据元素类型定义：
~~~cpp
typedef struct {
	KeyType key; //关键字域
	....         //其他域
} ElemType;
~~~
~~~cpp
typedef struct {
	ElemType *R; //表基址
	int length;      //表长
} SSTable;           //Sequential Search Table
SSTable ST;        //定义顺序表ST
~~~
算法：
~~~cpp
int Search_Seq(SSTable ST, KeyType key)
{
	for (int i = ST.length; i >= 1; --i)
		if (ST.R[i].key == key)
			return i;
	return 0;
}
~~~
或
~~~cpp
int Search_Seq(SSTable ST, KeyType key)
{
	for (int i = ST.length; ST.R[i].key != key && i > 0; --i);
	if (i > 0)
		return i;
	else
		return 0;
}
~~~
每执行一次循环都需要进行两次比较，改进：把待查关键字key存入表头（“哨兵”、“监视哨”）
~~~cpp
int Search_Seq(SSTable ST, KeyType key)
{
	ST.R[0].key = key;
	for (int i = ST.length; ST.R[i].key != key; --i);
	return i;
}
~~~
#### 2.1.2 时间效率分析
- 查找第i个元素需要比较n - i + 1次
- 查找失败需比较n + 1 次
- 时间复杂度：O(n)
- 查找成功时的平均查找长度，设表中各记录查找概率相等

$ASL(n) = (1 + 2+ ... + n) / n = (n + 1) / 2$

- 改进：可以根据被查找概率改变存储顺序或动态调整记录顺序
- 空间复杂度：一个辅助空间——O(1)
- 优点：算法简单，逻辑次序无要求，且不同存储结构均适用
- 缺点：ASL太长，时间效率太低
### 2.2 二分查找
- mid = (low + high) / 2
- key < mid则：high = mid - 1
- key > mid则：low = mid + 1
- key == mid，找到
#### 2.2.1 实现
1. 非递归
~~~cpp
int Search_Bin(SSTable ST, KeyType key)
{
	int low = 1, high = ST.length;   //置区间初值
	while (low <= high)
	{
		mid = (low + high) / 2;
		if (ST.R[mid].key == key)
			return mid;              //找到待查元素
		else if (key < ST.R[mid].key)//缩小查找区间
			high = mid - 1;          //继续在前半区间查找
		else
			low = mid + 1;           //继续在后半区间查找
	}
	return 0;                        //顺序表中不存在待查元素
}
~~~
2. 递归算法
~~~cpp
int Search_Bin(SSTable ST, KeyType key, int low, int high)
{
	if (low > high)
		return 0;//查找不到时返回0
	mid = (low + high) / 2;
	if (ST.R[mid].key == key)
		return mid;
	else if (key < ST.R[mid].key)
		return Search_Bin(ST, key, low, mid - 1);
	else
		return Search_Bin(ST, key, mid + 1, high);
}
~~~
#### 2.2.2 二叉查找性能分析
- 画出判定树
1. 查找成功：比较次数=路径上的结点数=结点的层数<=树的深度=|_ $ log_2n$ _| + 1
2. 查找不成功：比较次数=路径上的内部结点数，比较次数<=|_ $ log_2n$ _| + 1
- 平均查找长度ASL（成功时）:设表长 $n = 2^h - 1$ ，则 $h = log_2(n + 1)$ （此时，判定树为深度h的满二叉树），且表中每个记录的查找概率相等： $P_i = 1/n$

$$
ASL_{bs} = \sum_{i = 1}^{n}p_ic_i = 1 / n\sum_{i = 1}^{n}c_i
= 1/n\sum_{j = 1}^hj2^{j - 1} = (n + 1)/nlog_2(n + 1) - 1
= log_2(n + 1) - 1 (n > 50)
$$
- 优点：效率比顺序查找高
- 缺点：只适用于有序表，且限于顺序存储结构（对线性链表无效，因为找mid时即是顺序查找的过程）
