[查找的基本概念](#1-查找的基本概念)

[线性表的查找](#2-线性表的查找)

[树表查找](#3-树表查找)

[平衡二叉树（balanced binary tree）](#4-平衡二叉树balancedbinarytree)

[散列表的查找](#5-散列表的查找)

## 1 查找的基本概念
- 查找表：由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种灵便的结构
- 查找：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或（记录）
- 关键字：用来标识一个数据元素（或记录）的某个数据项的值
- 主关键字：可唯一标识一个记录的关键字
- 次关键字：用以标识若干记录的关键字
- 静态查找表：仅作“查询”（检索）操作的查找表
- 动态查找表：作“插入”和“删除”操作的查找表
- 平均查找长度： $\sum_{i = 1}^{n}p_ic_i$ ，n为记录的个数， $p_i$ 为查找第i个记录的概率（通常认为 $p_i = \frac{1}{n}$ ）， $c_i$ 为找到第i个记录所需的比较次数
## 2 线性表的查找
### 2.1 顺序查找
- 应用范围：
1. 顺序表或线性链表的静态查找表
2. 表内元素之间无序
#### 2.1.1 实现
数据元素类型定义：
~~~cpp
typedef struct {
	KeyType key; //关键字域
	....         //其他域
} ElemType;
~~~
~~~cpp
typedef struct {
	ElemType *R;     //表基址
	int length;      //表长
} SSTable;           //Sequential Search Table
SSTable ST;          //定义顺序表ST
~~~
算法：
~~~cpp
int Search_Seq(SSTable ST, KeyType key)
{
	for (int i = ST.length; i >= 1; --i)
		if (ST.R[i].key == key)
			return i;
	return 0;
}
~~~
或
~~~cpp
int Search_Seq(SSTable ST, KeyType key)
{
	for (int i = ST.length; ST.R[i].key != key && i > 0; --i);
	if (i > 0)
		return i;
	else
		return 0;
}
~~~
每执行一次循环都需要进行两次比较，改进：把待查关键字key存入表头（“哨兵”、“监视哨”）
~~~cpp
int Search_Seq(SSTable ST, KeyType key)
{
	ST.R[0].key = key;
	for (int i = ST.length; ST.R[i].key != key; --i);
	return i;
}
~~~
#### 2.1.2 时间效率分析
- 查找第i个元素需要比较n - i + 1次
- 查找失败需比较n + 1 次
- 时间复杂度：O(n)
- 查找成功时的平均查找长度，设表中各记录查找概率相等

$$
ASL(n) = \frac{1 + 2+ ... + n}{n} = \frac{n + 1}{2}
$$

- 改进：可以根据被查找概率改变存储顺序或动态调整记录顺序
- 空间复杂度：一个辅助空间——O(1)
- 优点：算法简单，逻辑次序无要求，且不同存储结构均适用
- 缺点：ASL太长，时间效率太低
### 2.2 二分查找
- mid = (low + high) / 2
- key < mid则：high = mid - 1
- key > mid则：low = mid + 1
- key == mid，找到
#### 2.2.1 实现
1. 非递归
~~~cpp
int Search_Bin(SSTable ST, KeyType key)
{
	int low = 1, high = ST.length;   //置区间初值
	while (low <= high)
	{
		mid = (low + high) / 2;
		if (ST.R[mid].key == key)
			return mid;              //找到待查元素
		else if (key < ST.R[mid].key)//缩小查找区间
			high = mid - 1;          //继续在前半区间查找
		else
			low = mid + 1;           //继续在后半区间查找
	}
	return 0;                        //顺序表中不存在待查元素
}
~~~
2. 递归算法
~~~cpp
int Search_Bin(SSTable ST, KeyType key, int low, int high)
{
	if (low > high)
		return 0;//查找不到时返回0
	mid = (low + high) / 2;
	if (ST.R[mid].key == key)
		return mid;
	else if (key < ST.R[mid].key)
		return Search_Bin(ST, key, low, mid - 1);
	else
		return Search_Bin(ST, key, mid + 1, high);
}
~~~
#### 2.2.2 二叉查找性能分析
- 画出判定树：需要比较几次就把记录位置放在第几层
1. 查找成功：比较次数=路径上的结点数=结点的层数<=树的深度= $\llcorner log_2n\lrcorner + 1$
2. 查找不成功：比较次数=路径上的内部结点数，比较次数<=$\llcorner log_2n\lrcorner + 1$
- 平均查找长度ASL（成功时）:设表长 $n = 2^h - 1$ ，则 $h = log_2(n + 1)$ （此时，判定树为深度h的满二叉树），且表中每个记录的查找概率相等： $P_i = \frac{1}{n}$

$$
ASL_{bs} = \sum_{i = 1}^{n}p_ic_i = \frac{1}{n}\sum_{i = 1}^{n}c_i
= \frac{1}{n}\sum_{j = 1}^hj2^{j - 1} = \frac{n + 1}{n}log_2(n + 1) - 1
\approx log_2(n + 1) - 1 (n > 50)
$$

- 优点：效率比顺序查找高
- 缺点：只适用于有序表，且限于顺序存储结构（对线性链表无效，因为找mid时即是顺序查找的过程）
### 2.3 分块查找
- 条件：
1. 将表分成几块，且表或者有序，或者分块有序（块间有序，块内无序）。若i < j，则第j块中所有记录的关键字均大于第i块中的最大关键字
2. 建立“索引表”（每个结点含有块内最大关键字域和指向本块第一个结点的指针，且按关键字有序）
- 查找过程：先确定待查记录所在块（顺序或折半查找），再在块内查找（顺序查找）
- 查找效率：

$$
ASL = L_b + L_w = log_2(\frac{n}{s} + 1) + \frac{s}{2}
$$

$$
(log_2n <= ASL_bs <= \frac{n+1}{2})
$$

其中， $L_b$ 为对索引表查找的ASL， $L_w$为对块内查找的ASL，s为每块内部的记录个数，n/s即块的数目

- 优点：插入和删除比较容易，无需进行大量移动
- 缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算
- 使用情况：线性表既要快速查找又经常动态变化
### 2.4 查找方法比较
| |顺序查找|二分查找|分块查找|
|:-:|:-:|:-:|:-:|
|ASL|最大|最小|中间|
|表结构|有序表、无序表|有序表|分块有序|
|存储结构|顺序表、线性链表|顺序表|顺序表、线性链表|
## 3 树表查找
### 3.1 二叉排序树（Binary Sort Tree）
#### 3.1.1 理论
- 又称为二叉搜索树、二叉查找树
- 性质： 二叉排序树或是空树，或是满足如下性质：
1. 若其左子树非空，则左子树上所有结点的值均小于根结点的值
2. 若其右子树非空，则右子树上所有结点的值均大于根结点的值
3. 其左右子树本身又各是一棵二叉排序树
4. 中序遍历非空二叉排序树所得数据元素序列是按关键字排列的递增有序序列
#### 3.1.2 实现
~~~cpp
typedef struct {
	KeyType key;        //关键字项
	InfoType otherinfo; //其他数据域
} ElemType;
typedef struct bstnode {
	ElemType data;                  //数据域
	struct bstnode* lchild, *rchild;//左右孩子域
} BSTNode, *BSTree;
BSTree T; //定义二叉排序树
~~~
~~~cpp
BSTree SearchBST(BSTree T, KeyType key)
{
	if ((!T) || key == T->data.key)
		return T;
	else if (key < T->data.key)
		return SearchBST(T->lchild, key); //在左子树中继续查找
	else
		return SearchBST(T->rchild, key); //在右子树中继续查找
}
~~~
#### 3.1.3 分析
- 含有n个结点的二叉排序树的平均查找长度和树的形态有关
- 最好情况： $ASL = log_2(n + 1) - 1$ ，与二分查找中的判定树相同，O( $log_2n$ )
- 最坏情况：单支树，树深度为n， $ASL = \frac{n + 1}{2}$ ，查找效率与顺序查找相同，O(n)
### 3.2 二叉排序树的插入
- 若二叉排序树为空，插入结点作为根结点
- 否则在左右子树上继续查找，若树中已有，不再插入，树中没有，查找直至某个叶子结点的左子树或右子树为空为止，插入结点应为该叶子结点的左孩子或右孩子
- 插入的元素一定在叶子结点上
### 3.3 二叉排序树的生成
- 构造二叉排序树的过程就是对无序序列进行排序的过程
- 插入的结点均为叶子结点，故无需移动其他结点
- 关键字的输入顺序不同，建立的二叉排序树不同
### 3.4 二叉排序树的删除
- 删除某结点后应将因删除结点而断开的二叉链表重新链接起来，并防止重新链接后树的高度增加
- 删除的三种情况：
1. 被删除的结点是叶子结点：直接删去该结点
2. 被删除的结点只有左子树或者只有右子树，用其左子树或右子树替换它（结点替换），其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树”
3. 被删除结点既有左子树也有右子树，可以以其中序前驱值替换之（值替换），然后再删除该前驱结点（前驱是左子树中最大结点），也可以用其后继替换之，然后再删除该后继结点（后继是右子树中最小结点）
## 4 平衡二叉树（balanced binary tree）
### 4.1 理论
- 又称AVL树（Adelson-Velskii and Landis）
- 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：
1. 左子树与右子树的高度之差的绝对值小于等于1
2. 左子树和右子树也是平衡二叉树
- 为方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差，这个数字称为结点的平衡因子（BF)，平衡二叉树上所有结点的平衡因子只能是-1，0或1
- 对于一棵有n个结点的AVL树，其高度保持在O( $log_2n$ )数量级，ASL也保持在O( $log_2n$ )量级
### 4.2 失衡二叉排序树的分析与调整
- 在一个平衡二叉排序树上插入一个结点时，有可能导致失衡，即出现平衡因子绝对值大于1的结点
- 不止一个失衡点时，失衡结点为最小失衡子树的根结点
- 平衡调整的四种类型：LL型、LR型、RL型、RR型
- 调整原则：1）降低高度2）保持二叉排序树性质
## 5 散列表的查找
### 5.1 概念
- 散列方法（杂凑法）：选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地质单元中元素关键码进行对比，确定查找是否成功
- 散列函数（杂凑函数、哈希函数）：散列方法中使用的函数， $H(key) = k$
- 散列表（杂凑表）：按上述思想构造的表
- 冲突：不同的关键码映射到同一个散列地址
- 冲突是不可避免的，只能尽量减少
- 同义词：具有相同散列函数值的多个关键字
-  使用散列表要解决好两个问题：
1. 构造好的散列函数

&ensp;&ensp;a）所选函数尽可能简单，以便提高转换速度

&ensp;&ensp;b）所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费

2. 制定一个好的解决冲突的方案

&ensp;&ensp;查找时，如果从散列函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其他相关单元
### 5.2 方法
#### 5.2.1 直接定址法
$$
Hash(key) = a*key + b（a、b为常数）
$$

- 优点：以关键码key的某个线性函数值为散列地址，不会产生冲突
- 缺点：要占用连续地址空间，空间效率低
#### 5.2.2 除留余数法
$$
Hash(key) = key \quad mod \quad p
$$

- 关键：如何选取合适的p
- 技巧：设表长为m，取p <= m且为质数
### 5.3 处理冲突的方法
#### 5.3.1 开放地址法
- 基本思想：有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入
- 例如除留余数法：

$$
H_i = (Hash(key) + d_i) mod m
$$

&ensp;&ensp;$d_i$ 为增量序列

- 常用方法：
1. 线性探测法： $d_i$ 为1，2，...，m - 1线性序列
2. 二次探测法： $d_i$ 为 $1^2$ ， $-1^2$ ， $2^2$ ， $-2^2$，...， $q^2$ 线性序列
3. 伪随机探测法： $d_i$ 为伪随机数序列， $d_i$ 为伪随机数
#### 5.3.2 链地址法（拉链法）
- step1：取数据元素的关键字key，计算其散列函数值（地址），若该地址对应的链表为空，则将该元素插入此链表，否则执行step2解决冲突
- step2：根据选择的冲突处理方法，计算关键字key的下一个存储地址，若该地址对应的链表不为空，则利用链表的前插法或后插法将该元素插入此链表
- 优点：非同义词不会冲突，无“聚集”现象；链表上结点空间动态申请，更适合于表长不确定的情况
### 5.4 散列表的查找效率分析
- 平均查找长度ASL取决于：
1. 散列函数
2. 处理冲突的方法
3. 散列表的装填因子 $\alpha$ ， $\alpha$ 越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多

$$
\alpha = \frac{表中填入的记录数}{哈希表的长度}
$$

- ASL与装填因子 $\alpha$ 有关，既不是严格的O(1)，也不是O(n)

$$
ASL \approx 1 + \frac{\alpha}{2} （拉链法）
$$

$$
ASL \approx \frac{1}{2}(1 + \frac{1}{1-\alpha})（线性探测法）
$$

$$
ASL \approx -\frac{1}{\alpha}ln(1 - \alpha)（随机探测法）
$$

- 几点结论：
1. 散列表技术具有很好的平均性能，优于一些传统的技术
2. 链地址法优于开地址法
3. 除留余数法作散列函数优于其他类型函数

