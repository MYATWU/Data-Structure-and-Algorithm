## 1 图的定义和术语
- 图：G = (V, E)
- V：顶点（数据元素）的有穷非空集合
- E：边的有穷集合
- 无向图：每条边都是无方向的
- 有向图：每条边都是有方向的
- 完全图：任意两个点都有一条边相连
- 无向完全图：n个顶点，n(n - 1)/2条边
- 有向完全图：n个顶点，n(n - 1)条边，任意两个点都有两条边相连
- 稀疏图：有很少边或弧的图（e < nlogn)
- 稠密图：有较多边或弧的图
- 网：边/弧带权的图
- 邻接：有边/弧相连的两个顶点之间的关系，存在( $v_i$ , $v_j$ )（两点之间无序），则称 $v_i$ 和 $v_j$互为邻接点，存在< $v_i$ , $v_j$ >，则称 $v_i$ 邻接到 $v_j$ ，$v_j$ 邻接于 $v_i$
- 关联（依附）：边/弧与顶点之间的关系
- 存在( $v_i$ , $v_j$ )/< $v_i$ , $v_j$ >，则称该边/弧关联于 $v_i$ 和 $v_j$
- 顶点的度：与该顶点相关联的边的数目，记为TD(v)，在有向图中，顶点的度等于该顶点的入度和出度之和。顶点v的入度是以v为终点的有向边的条数，记作ID(v)，顶点v的出度是以v为起点的有向边的条数，记作OD(v)
- 当有向图中仅1个顶点的入度为0，其余顶点的入度均为1，此时的形状为有向树
- 路径：接续的边构成的顶点序列
- 路径长度：路径上边或弧的数目/权值之和
- 回路（环）：第一个顶点和最后一个顶点相同的路径
- 简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径
- 简单回路（简单环）：除路径起点和终点相同外，其余顶点均不相同的路径
- 连通图（强连通图）：在无（有）向图G = (V, {E})中，若对任何两个顶点v，u都存在v到u的路径，则称G是连通图（强连通图）
- 权：图中边或弧所具有的相关数称为权，表明从一个顶点到另一个顶点的距离或耗费
- 子图：设有两个图G = (V, {E})、G1 = (V1, {E1})，若V1是V的子集，E1是E的子集，则称G1是G的子图
- 连通分量（ 强连通分量）：无（有）向图G的极大连通子图称为G的连通分量（强连通分量）
- 极大连通子图：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通
- 极小连通子图：该子图是G的连通子图，在该子图中删除任何一条边/弧，子图不再连通
- 生成树：包含无向图G所有顶点的极小连通子图
- 生成森林：对非连通图，由各个连通分量的生成树的集合
## 2 图的类型定义
### 2.1 邻接矩阵
#### 2.1.1 无向图的邻接矩阵
- 无向图的邻接矩阵是对角线为0的对称矩阵
- 顶点i的度 = 第i行（列）中1的个数
- 完全图的邻接矩阵中，对角元素为0，其余为1
#### 2.1.2 有向图的邻接矩阵
- 第i行含义：以结点 $v_i$ 为尾的弧（即出度边）
- 第i列含义：以结点 $v_i$ 为头的弧（即入度边）
- 有向图的邻接矩阵可能不是对称的
- 顶点的出度 = 第i行元素之和
- 顶点的入度 = 第i列元素之和
- 顶点的度 = 第i行元素之和 + 第i列元素之和
#### 2.1.3 邻接矩阵的存储表示
~~~cpp
#define Maxlnt 32767   //表示极大值，即无穷大
#define MVNum 100      //最大顶点数
typedef char VerTexType//设顶点数据类型为字符型
typedef int ArcType    //设边的权值类型为整型

typedef struct {
	VerTexType vexs[MVNum];     //顶点表
	ArcType arcs[MVNum][MVNum]; //邻接矩阵
	int vexnum, arcnum;         //图的当前点数和边数
} AMGraph;
~~~
#### 2.1.4 邻接矩阵创建无向网
~~~cpp
Status CreatUDN(AMGraph& G)
{
	cin >> G.vexnum >> G.arcnum; //输入总顶点数，总边数
	for(int i = 0; i < G.vexnum; ++i)
		cin >> G.vexs[i];
	for (int i = 0; i < G.vexnum; ++i)
		for (int j = 0; j < G.vexnum; ++j)
			G.arcs[i][j] = Maxlnt;
	for (int i = 0; i < G.arcnum; ++i)
	{
		cin >> v1 >> v2 >> w;
		p1 = LocateVex(G, v1);
		p2 = LocateVex(G, v2);
		G.arcs[p1][p2] = w;
		G.arcs[p2][p1] = arcs[p1][p2];
	}
	return OK;
}
int LocateVex(const AMGraph& G, VerTexType v)
{
	for (int i = 0; i < G.vexnum; ++i)
	{
		if (G.vexs[i] == v)
			return i;
	}
	return -1;
}
~~~
### 2.2 邻接表
- 顶点：按编号顺序将顶点数据存储在一维数组中
- 关联同一顶点的边（以顶点为尾的弧）：用线性链表存储

#### 2.2.1 无向图
- 邻接表不唯一（同一顶点的边在链表中的位置可以交换）
- 若无向图中有n个顶点，e条边，则其邻接表需n个头结点和2e个表结点。适宜存储稀疏图
- 无向图中顶点 $v_i$ 的度为第i个单链表中的结点数  
#### 2.2.2 有向图

**邻接表**

- 顶点 $v_i$ 的出度为第i个单链表中结点个数
- 顶点 $v_i$ 的入度为整个单链表中邻接点域值是i - 1的结点个数

**逆邻接表**
- 顶点 $v_i$ 的入度为第i个单链表中结点个数
- 顶点 $v_i$ 的出度为整个单链表中邻接点域值是i - 1的结点个数
#### 2.2.3 图的邻接表存储表示
- 顶点
~~~cpp
typedef struct VNode {
	VerTexType data;
	ArcNode* firstarc;
} VNode, AdjList[MVNum];
~~~
~~~cpp
AdjList v;
~~~
相当于
~~~cpp
VNode v[MVNode];
~~~
- 边/弧
~~~cpp
#define MVNode 100
typedef struct arcnode  {
	int adjvex;
	struct arcnode* nextarc;
	OtherInfo info;
} ArcNode;
~~~
- 图
~~~cpp
typedef struct algraph {
	AdjList vertices;
	int vexnum, arcnum;
} ALGraph;
~~~
#### 2.2.4 采用邻接表创建无向网
~~~cpp
Status CreatUDG(ALGraph& G)
{
	cin >> G.vexnum >> G.arcnum;
	for (int i = 0; i < G.vexnum; ++i)
	{
		cin >> G.vertices[i].data;
		G.vertices[i].firstarc = NULL;
	}
	for (int k = 0; k < G.arcnum; ++k)
	{
		cin >> v1 >> v2;
		i = LocateVex(G, v1);
		j = LocateVex(G, v2);
		//8行都有是无向图，只有前4行是有向图的邻接表
		newarc1 = new ArcNode;
		newarc1->adjvex = j;
		newarc1->nextarc = G.vertices[i].firstarc;
		G.vertices[i].firstarc = newarc1;
		//只有这4行是有向图的逆邻接表
		newarc2 = new ArcNode;
		newarc2->adjvex = i;
		newarc2->nextarc = G.vertices[j].firstarc;
		G.vertices[j].firstarc = newarc2;
	}
	return OK;
}
~~~
### 2.3 邻接矩阵和邻接表比较
1. 联系：邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数
2. 区别：
- 对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关，与头插法/尾插法等算法有关）
- 邻接矩阵的空间复杂度为O( $n^2$ )，而邻接表的空间复杂度为O(n + e)
3. 用途：邻接矩阵多用于稠密图，邻接表多用于稀疏图
## 3 图的遍历
### 3.1 深度优先遍历(Depth First Search, DFS)
- 类似于树的先根遍历
#### 3.1.1 实现
- 邻接矩阵的深度优先搜索遍历
~~~cpp
void DFS(AMGraph G, int v)
{
	cout << v;
	visited[v] = true; //访问第v个顶点
	for (int w = 0; w < G.vexnum; ++w) //依次检查邻接矩阵v所在的行
	{
		if ((G.arcs[v][w]  != 0) && (!visited[w])
			DFS(G, w);
		//w是v的邻接点，如果w未被访问，则递归调用DFS
	}
}
~~~
#### 3.1.2 效率分析
- 用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为O( $n^2$ )
- 用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为O( $n + e$ )
- 结论：
1. 稠密图适于在邻接矩阵上进行深度遍历
2. 稀疏图适于在邻接表上进行深度遍历
### 3.2 广度优先遍历(Breadth First Search, BFS)
#### 3.2.1 实现
- 按广度优先非递归遍历连通图G
~~~cpp
void BFS(Graph G, int v)
{
	cout << v;
	visited[v] = true; //访问第v个顶点
	InitQueue(Q);     //辅助队列初始化，置空
	EnQueue(Q, v);   //v进队
	while (!QueueEmpty(Q))
	{
		DeQueue(Q, u);
		for (int w = FirstAdjVex(G, u); w >= 0; w = NextAdjVex(G, u, w))
			if (!visited[w])
			{
				cout << w;
				visited[w] = true;
				EnQueue(Q, w);
			}
	}
}
~~~
#### 3.2.2 BFS算法效率分析
- 用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为O( $n^2$ )
- 用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为O( $n + e$ )
### 3.3 DFS和BFS算法效率比较
- 空间复杂度相同，都是O(n)（借用了堆栈或队列）
- 时间复杂度只与存储结构（邻接矩阵或邻接表）有关，而与搜索路径无关
## 4 图的应用
### 4.1 最小生成树
- 生成树：所有顶点均由边连接在一起，但不存在回路的图
- 一个图可以有许多棵不同的生成树
- 所有生成树具有以下共同特点：
1. 生成树顶点个数与图的顶点个数相同
2. 生成树是图的极小连通子图，去掉一条边则非连通
3. 一个有n个顶点的连通图的生成树有n - 1条边
4. 在生成树中再加一条边必然形成回路
5. 生成树中任意两个顶点间的路径是唯一的

**无向图的生成树**
1. 深度优先生成树
2. 广度优先生成树
- 最小生成树：给定一个无向网络，在该网的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树
- 最小生成树应用：n个城市间修路最经济规划
- MST(Minimum Spanning Tree)性质（一种贪心算法）：设N = (V, E)是一个连通网，U是顶点集V的一个非空子集，若边(u, v)是一条具有最小权值的边，其中u属于U， v属于V - U，则必存在一棵包含边(u, v)的最小生成树
- 构造最小生成树方法一：普里姆（Prim）算法
- 构造最小生成树方法二：克鲁斯卡尔（Kruskal）算法
- 两种算法比较

|算法名|普里姆算法|克鲁斯卡尔算法|
|-|-|-|
|算法思想|选择点|选择边|
|时间复杂度|O( $n^2$ )|O( $eloge$ )|
|适用范围|稠密图|稀疏图|
### 4.2 最短路径问题
1. 单源最短路径——用Dijkstra（迪杰斯特拉）算法
2. 所有顶点间的最短路径——用Floyd（弗洛伊德）算法

